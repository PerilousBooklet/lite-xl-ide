{
    "IsPrime": {
        "prefix": "algo-is_prime",
        "body": [
            "def is_prime(n: int) -> bool:",
            "\t\"\"\"",
            "\tReturn True if n is prime, False otherwise.",
            "\t\"\"\"",
            "\tif n < 2:",
            "\t\treturn False",
            "\telif n < 4:",
            "\t\treturn True",
            "\telif n % 2 == 0 or n % 3 == 0:",
            "\t\treturn False",
            "\telse:",
            "\t\tfor i in range(5, int(n**0.5)+1, 6):",
            "\t\t\tif n % i == 0 or n % (i+2) == 0:",
            "\t\t\t\treturn False",
            "\t\treturn True"
        ],
        "description": "Check whether a number is prime"
    },
    "BinaryExponentiation": {
        "prefix": "algo-fast_power",
        "body": [
            "def fast_power(x: float, y: int) -> int:",
            "\t\"\"\"",
            "\tReturn x^y with O(log(n)) Time Complexity.",
            "\t\"\"\"",
            "\tif y == 0:",
            "\t\treturn 1",
            "\telif y == 1:",
            "\t\treturn x",
            "\telif y == -1:",
            "\t\treturn 1/x",
            "\telse:",
            "\t\tans = fast_power(x, y//2)",
            "\t\tif y % 2 == 0:",
            "\t\t\treturn ans*ans",
            "\t\telse:",
            "\t\t\treturn ans * ans * x\n"
        ],
        "description": "performs a^b operation with O(log(n)) Complexity"
    },
    "Greatest Common Divisor": {
        "prefix": "algo-gcd.hcf.gcf",
        "body": [
            "def greatest_common_divisor(a: int, b: int) -> int:",
            "\t\"\"\"",
            "\tEuclidean Algorithm:  GCD(A,0) = A  GCD(0,B) = B",
            "\tA in quotient Q remainder R form (A = â‹…QB + R)",
            "\tThe greatest divisor can divide (A - QB) Linear Combination aka R as well ",
            "\tThus gcd(A,B) = gcd(B,R) notice we just swap the position and use R",
            "\tso we repeat getting the R to 0\n",
            "\t>>> greatest_common_divisor(7,5)",
            "\t1\n",
            "\t>>> greatest_common_divisor(121, 11)",
            "\t11",
            "\t\"\"\"",
            "\tif a < b:",
            "\t\ta, b = b, a\n",
            "\twhile a % b != 0:",
            "\t\ta, b = b, a % b\n",
            "\treturn b"
        ],
        "description": "Greatest Common Divisor aka Greatest Common Factor of two number"
    },
    "BinarySearchTree": {
        "prefix": "algo-bst",
        "body": [
            "from __future__ import annotations",
            "from typing import Iterator\n\n",
            "class Node:",
            "\tdef __init__(self, label: int, parent: Node | None) -> None:",
            "\t\tself.label = label",
            "\t\tself.parent = parent",
            "\t\tself.left: Node | None = None",
            "\t\tself.right: Node | None = None\n\n",
            "class BinarySearchTree:",
            "\t\"\"\"",
            "\tThis is a python3 implementation of binary search tree using recursion",
            "\t\"\"\"",
            "\tdef __init__(self) -> None:",
            "\t\tself.root: Node | None = None\n",
            "\tdef empty(self) -> None:",
            "\t\t\"\"\"",
            "\t\tEmpties the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> assert t.root is None",
            "\t\t>>> t.put(8)",
            "\t\t>>> assert t.root is not None",
            "\t\t\"\"\"",
            "\t\tself.root = None\n",
            "\tdef is_empty(self) -> bool:",
            "\t\t\"\"\"",
            "\t\tChecks if the tree is empty\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.is_empty()",
            "\t\tTrue",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.is_empty()",
            "\t\tFalse",
            "\t\t\"\"\"",
            "\t\treturn self.root is None\n",
            "\tdef put(self, label: int) -> None:",
            "\t\t\"\"\"",
            "\t\tPut a new node in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> assert t.root.parent is None",
            "\t\t>>> assert t.root.label == 8\n",
            "\t\t>>> t.put(10)",
            "\t\t>>> assert t.root.right.parent == t.root",
            "\t\t>>> assert t.root.right.label == 10\n",
            "\t\t>>> t.put(3)",
            "\t\t>>> assert t.root.left.parent == t.root",
            "\t\t>>> assert t.root.left.label == 3",
            "\t\t\"\"\"",
            "\t\tself.root = self._put(self.root, label)\n",
            "\tdef _put(self, node: Node | None, label: int, parent: Node | None = None) -> Node:",
            "\t\tif node is None:",
            "\t\t\tnode = Node(label, parent)",
            "\t\telse:",
            "\t\t\tif label < node.label:",
            "\t\t\t\tnode.left = self._put(node.left, label, node)",
            "\t\t\telif label > node.label:",
            "\t\t\t\tnode.right = self._put(node.right, label, node)",
            "\t\t\telse:",
            "\t\t\t\traise Exception(f\"Node with label {label} already exists\")\n",
            "\t\treturn node\n",
            "\tdef search(self, label: int) -> Node:",
            "\t\t\"\"\"",
            "\t\tSearches a node in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> node = t.search(8)",
            "\t\t>>> assert node.label == 8\n",
            "\t\t>>> node = t.search(3)",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Node with label 3 does not exist",
            "\t\t\"\"\"",
            "\t\treturn self._search(self.root, label)\n",
            "\tdef _search(self, node: Node | None, label: int) -> Node:",
            "\t\tif node is None:",
            "\t\t\traise Exception(f\"Node with label {label} does not exist\")",
            "\t\telse:",
            "\t\t\tif label < node.label:",
            "\t\t\t\tnode = self._search(node.left, label)",
            "\t\t\telif label > node.label:",
            "\t\t\t\tnode = self._search(node.right, label)\n",
            "\t\treturn node\n",
            "\tdef remove(self, label: int) -> None:",
            "\t\t\"\"\"",
            "\t\tRemoves a node in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.remove(8)",
            "\t\t>>> assert t.root.label == 10\n",
            "\t\t>>> t.remove(3)",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Node with label 3 does not exist",
            "\t\t\"\"\"",
            "\t\tnode = self.search(label)",
            "\t\tif node.right and node.left:",
            "\t\t\tlowest_node = self._get_lowest_node(node.right)",
            "\t\t\tlowest_node.left = node.left",
            "\t\t\tlowest_node.right = node.right",
            "\t\t\tnode.left.parent = lowest_node",
            "\t\t\tif node.right:",
            "\t\t\t\tnode.right.parent = lowest_node",
            "\t\t\tself._reassign_nodes(node, lowest_node)",
            "\t\telif not node.right and node.left:",
            "\t\t\tself._reassign_nodes(node, node.left)",
            "\t\telif node.right and not node.left:",
            "\t\t\tself._reassign_nodes(node, node.right)",
            "\t\telse:",
            "\t\t\tself._reassign_nodes(node, None)\n",
            "\tdef _reassign_nodes(self, node: Node, new_children: Node | None) -> None:",
            "\t\tif new_children:",
            "\t\t\tnew_children.parent = node.parent\n",
            "\t\tif node.parent:",
            "\t\t\tif node.parent.right == node:",
            "\t\t\t\tnode.parent.right = new_children",
            "\t\t\telse:",
            "\t\t\t\tnode.parent.left = new_children",
            "\t\telse:",
            "\t\t\tself.root = new_children\n",
            "\tdef _get_lowest_node(self, node: Node) -> Node:",
            "\t\tif node.left:",
            "\t\t\tlowest_node = self._get_lowest_node(node.left)",
            "\t\telse:",
            "\t\t\tlowest_node = node",
            "\t\t\tself._reassign_nodes(node, node.right)\n",
            "\t\treturn lowest_node\n",
            "\tdef exists(self, label: int) -> bool:",
            "\t\t\"\"\"",
            "\t\tChecks if a node exists in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.exists(8)",
            "\t\tTrue\n",
            "\t\t>>> t.exists(3)",
            "\t\tFalse",
            "\t\t\"\"\"",
            "\t\ttry:",
            "\t\t\tself.search(label)",
            "\t\t\treturn True",
            "\t\texcept Exception:",
            "\t\t\treturn False\n",
            "\tdef get_max_label(self) -> int:",
            "\t\t\"\"\"",
            "\t\tGets the max label inserted in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.get_max_label()",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Binary search tree is empty\n",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.get_max_label()",
            "\t\t10",
            "\t\t\"\"\"",
            "\t\tif self.root is None:",
            "\t\t\traise Exception(\"Binary search tree is empty\")\n",
            "\t\tnode = self.root",
            "\t\twhile node.right is not None:",
            "\t\t\tnode = node.right\n",
            "\t\treturn node.label\n",
            "\tdef get_min_label(self) -> int:",
            "\t\t\"\"\"",
            "\t\tGets the min label inserted in the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> t.get_min_label()",
            "\t\tTraceback (most recent call last):",
            "\t\t\t...",
            "\t\tException: Binary search tree is empty\n",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.get_min_label()",
            "\t\t8",
            "\t\t\"\"\"",
            "\t\tif self.root is None:",
            "\t\t\traise Exception(\"Binary search tree is empty\")\n",
            "\t\tnode = self.root",
            "\t\twhile node.left is not None:",
            "\t\t\tnode = node.left\n",
            "\t\treturn node.label\n",
            "\tdef inorder_traversal(self) -> Iterator[Node]:",
            "\t\t\"\"\"",
            "\t\tReturn the inorder traversal of the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> [i.label for i in t.inorder_traversal()]",
            "\t\t[]\n",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.put(9)",
            "\t\t>>> [i.label for i in t.inorder_traversal()]",
            "\t\t[8, 9, 10]",
            "\t\t\"\"\"",
            "\t\treturn self._inorder_traversal(self.root)\n",
            "\tdef _inorder_traversal(self, node: Node | None) -> Iterator[Node]:",
            "\t\tif node is not None:",
            "\t\t\tyield from self._inorder_traversal(node.left)",
            "\t\t\tyield node",
            "\t\t\tyield from self._inorder_traversal(node.right)\n",
            "\tdef preorder_traversal(self) -> Iterator[Node]:",
            "\t\t\"\"\"",
            "\t\tReturn the preorder traversal of the tree\n",
            "\t\t>>> t = BinarySearchTree()",
            "\t\t>>> [i.label for i in t.preorder_traversal()]",
            "\t\t[]\n",
            "\t\t>>> t.put(8)",
            "\t\t>>> t.put(10)",
            "\t\t>>> t.put(9)",
            "\t\t>>> [i.label for i in t.preorder_traversal()]",
            "\t\t[8, 10, 9]",
            "\t\t\"\"\"",
            "\t\treturn self._preorder_traversal(self.root)\n",
            "\tdef _preorder_traversal(self, node: Node | None) -> Iterator[Node]:",
            "\t\tif node is not None:",
            "\t\t\tyield node",
            "\t\t\tyield from self._preorder_traversal(node.left)",
            "\t\t\tyield from self._preorder_traversal(node.right)"
        ],
        "description": "Binary Search Tree example"
    },
    "SegmentTree": {
        "prefix": "algo-seg_tree",
        "body": [
            "import math\n\n",
            "class SegmentTree:",
            "\tdef __init__(self, A):",
            "\t\tself.N = len(A)",
            "\t\tself.st = [0] * (",
            "\t\t\t4 * self.N",
            "\t\t)  # approximate the overall size of segment tree with array N",
            "\t\tself.build(1, 0, self.N - 1)",
            "\t\tself.A = A\n",
            "\tdef left(self, idx):",
            "\t\treturn idx * 2\n",
            "\tdef right(self, idx):",
            "\t\treturn idx * 2 + 1\n",
            "\tdef build(self, idx, l, r):  # noqa: E741",
            "\t\tif l == r:  # noqa: E741",
            "\t\t\tself.st[idx] = self.A[l]",
            "\t\telse:",
            "\t\t\tmid = (l + r) // 2",
            "\t\t\tself.build(self.left(idx), l, mid)",
            "\t\t\tself.build(self.right(idx), mid + 1, r)",
            "\t\t\tself.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])\n",
            "\tdef update(self, a, b, val):",
            "\t\treturn self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)\n",
            "\tdef update_recursive(self, idx, l, r, a, b, val):  # noqa: E741",
            "\t\t\"\"\"",
            "\t\tupdate(1, 1, N, a, b, v) for update val v to [a,b]",
            "\t\t\"\"\"",
            "\t\tif r < a or l > b:",
            "\t\t\treturn True",
            "\t\tif l == r:  # noqa: E741",
            "\t\t\tself.st[idx] = val",
            "\t\t\treturn True",
            "\t\tmid = (l + r) // 2",
            "\t\tself.update_recursive(self.left(idx), l, mid, a, b, val)",
            "\t\tself.update_recursive(self.right(idx), mid + 1, r, a, b, val)",
            "\t\tself.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])",
            "\t\treturn True\n",
            "\tdef query(self, a, b):",
            "\t\treturn self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)\n",
            "\tdef query_recursive(self, idx, l, r, a, b):  # noqa: E741",
            "\t\t\"\"\"",
            "\t\tquery(1, 1, N, a, b) for query max of [a,b]",
            "\t\t\"\"\"",
            "\t\tif r < a or l > b:",
            "\t\t\treturn -math.inf",
            "\t\tif l >= a and r <= b:  # noqa: E741",
            "\t\t\treturn self.st[idx]",
            "\t\tmid = (l + r) // 2",
            "\t\tq1 = self.query_recursive(self.left(idx), l, mid, a, b)",
            "\t\tq2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)",
            "\t\treturn max(q1, q2)\n",
            "\tdef showData(self):",
            "\t\tshowList = []",
            "\t\tfor i in range(1, self.N + 1):",
            "\t\t\tshowList += [self.query(i, i)]",
            "\t\tprint(showList)"
        ],
        "description":"Segment Tree example"
    }
}